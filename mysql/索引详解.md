## 带着问题走进索引

 

问题1. 索引为何使用B+Tree数据结构? 而不是其他数据结构,如 链表,Hash,红黑树等.

 

问题2. 为什么表中需要 is_deleted字段来标记是否删除. 直接物理删除数据对索引结构有什么样的影响?

 

问题3. 创建表时,是否一定要设置主键? 如果不设置主键会怎么样? (显式主键与隐式主键)?

 

问题4.主键为什么大部分情况下 主键要设置为自动自增(AUTO_INCREMENT)?

 

问题5: 为什么频繁变化的数据,不适合作为索引字段?

 

问题6: 为什么变化基数小(唯一性较差)字段,比如 status,type等字段. 不适合作为索引字段?  

```
案例:dbmallorder table: t_order_refund 
SELECT * from t_order_refund WHERE apply_type = 1
唯一性计算公式: select count(distinct col)/count(*)  from tablele
select count(distinct apply_type )/count(*)  from t_order_refund
计算非聚集索引的数据重复率: 1 / count(distinct col)/count(*)
 
 
show index from t_order
```

## 索引为何使用B+Tree结构

而不是 平衡二叉树 或者 链表

### **1.数据库数据存储的方式**

以磁盘文件的方式存储,比如
 ![](C:\Users\vfghk\Desktop\image2019-6-27 15_43_44.png)

  

​    .ibd 是MySQL数据文件、索引文件.

 

### **2.从数据库读取(查询)数据的原理**

表现形式为select语句

就是从磁盘文件中读取数据的,select操作的时间，取决于执行**磁盘IO的次数**，次数越少,速度越快,查询时间就越少.

磁盘读取依靠的是机械运动，分为寻道时间、旋转延迟、传输时间三个部分 这三个部分耗时相加就是一次磁盘IO的时间 大概9ms左右

图解示例:


![](C:\Users\vfghk\Desktop\image2019-6-25 15_55_37.png)



在内存中读取数据的速度,远比在磁盘中读取速度快.

操作系统对此做了优化：**预读；**

每一次IO时，不仅仅把当前磁盘地址的数据加载到内存，同时也把相邻数据也加载到内存缓冲区中。

每次磁盘IO读取的数据我们称之为一页（page）

一页的数据大小为4K 



一次磁盘IO操作可以取出物理存储中相邻的一大片数据，

如果查询的索引数据（就是从根节点一直到叶子节点整个过程中查询的节点数）都集中在该区域，

那么只需要一次磁盘IO，否则就需要多次磁盘IO



### **3.可供使用的数据结构有哪些?**

1.节点深度不能太深  因为 节点深度决定了磁盘IO的次数

2.单个节点(页/磁盘块)存储的数据不能太小. 

  太小的话,不能很好的利用预读功能,从而导致IO比较频繁



**最先被排除掉的**

**Hash** 

**可以做id查询 比如 where id = 100 迅速可以找到**

**但是做 where id > 100 时, 无法满足范围查询的情况.**

https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

**A.二叉树 Binary Search Trees**

 

https://www.cs.usfca.edu/~galles/visualization/BST.html

 

 

变成了线性链表.