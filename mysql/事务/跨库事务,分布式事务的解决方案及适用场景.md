[TOC]



## 总结

不同业务场景应按需引入不同的事务形态，在条件允许的情况下，

建议按照如下次序选择对应的事务形态：

**单机事务》基于消息的事务》基于补偿的事务》TCC事务**





## 优先使用单机事务

> 这个相信大家都很清楚，在条件允许的情况下，我们应该尽可能地使用单机事务，
因为单机事务里，无需额外协调其他数据源，减少了网络交互时间消耗以及协调时所需的存储IO消耗，
在修改等量业务数据的情况下，单机事务将会有更高的性能。
但单机数据库由于 业务逻辑解耦等因素进行了数据库垂直拆分、
或者由于单机数据库性能压力等因素进行了数据库水平拆分之后，
**数据分布于多个数据库，这时若需要对多个数据库的数据进行协调变更，则需要引入分布式事务。**

分布式事务的模式有很多种，那究竟要怎么选择适合业务的模式呢？
以下我们将从使用场景、性能、开发成本这几个方面进行分析。



## 基于业务日志表的实现方案

![image-20200515142204291](C:\Users\aaa\AppData\Roaming\Typora\typora-user-images\image-20200515142204291.png)

> 
>
> 

## 基于消息队列实现的事务方案

### 适用场景

> **事务的提交或回滚,只取决于事务发起方**
>
> 举个例子，业务规则：某笔订单成功后，为用户加一定的积分。
>
> 在这条规则里，管理订单数据源的服务为事务发起方，管理积分数据源的服务为事务跟随者。
>
> 从这个过程可以看到，基于消息队列实现的事务存在以下操作：
>
> - 订单服务  创建订单，提交本地事务
> - 订单服务  发布一条消息
> - 积分服务  收到消息后加积分
>
> 我们可以看到它的整体流程是比较简单的，同时业务开发工作量也不大：
>
> - 编写订单服务里订单创建的逻辑
> - 编写积分服务里增加积分的逻辑
>
> 可以看到该事务形态过程简单，性能消耗小，发起方与跟随方之间的流量峰谷可以使用队列填平，
>
> 同时业务开发工作量也基本与单机事务没有差别，都不需要编写反向的业务逻辑过程。
>
> 因此基于消息队列实现的事务是我们除了单机事务外最优先考虑使用的形态。

![image-20200514160446496](http://qa3sq0khl.bkt.clouddn.com/image-20200514160446496.png)

### 存在的问题

>服务A 处理完毕后
>
>1.不确定  消息一定发送成功
>
>2.不确定  服务器B是否一定处理成功

## 基于消息队列+本地事务日志表实现的事务方案 

> 新增一张 事务消息 日志表 t_transaction_log

![image-20200514170302166](http://qa3sq0khl.bkt.clouddn.com/image-20200514170302166.png)

## TCC方案

![image-20200514175410082](http://qa3sq0khl.bkt.clouddn.com/image-20200514175410082.png)