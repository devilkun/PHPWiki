# 什么是负载均衡?

> 将请求 均匀的分配在多个操作单元上

同构服务器(配置相同) 重点在于均衡

异构服务器(配置不同) 重点在于, 负载与能力匹配



端=>反向代理=>站点应用=>服务层=>缓存层=>数据库层

**每一个下游,都有多个上游调用 ,做到每一个上游对下游的调用都是均匀的,就能够实现系统整理的负载均衡.**



## 反向代理层的负载均衡

同一个域名设置不同的外网解析,使用DNS轮询的方式  实现nginx的流量均衡分摊



![image-20200913145146721](D:\code\PHPWiki\架构设计\必须搞定负载均衡.assets\image-20200913145146721.png)

## 站点应用层的高可用

> 在nginx处,配置反向代理    使用轮询 或者 自定义权重的方式  或者ip哈希的方式 

![image-20200913145300039](D:\code\PHPWiki\架构设计\必须搞定负载均衡.assets\image-20200913145300039.png)



## 微服务层的负载均衡

> 通过连接池来实现

![image-20200913145517656](D:\code\PHPWiki\架构设计\必须搞定负载均衡.assets\image-20200913145517656.png)



## 数据层的均衡(Cache&DB)

### 数据均衡 与 请求均衡

#### id范围水平切分

> 数据均衡 ,但是请求不均衡

#### Hash水平切分

> 数据均衡,且请求也相对均衡,缺点是再次扩展性较差

### 

# 异构服务器的负载均衡

## 异构服务器使用平均分配有什么后果?

> 1.配置低的服务器   超负荷运行,扛不住压力
>
> 2.配置高的服务器, 利用率不足,资源浪费
>
> 应该
>
> 根据服务器的处理能力来动态的,进行负载均衡,同时,实施过载保护

## 使用连接池组件,实施异构服务器的负载均衡 

### 方案1:静态权重

优点: 可以自定义的分配流量

缺点:无法自适应的进行动态调节 	



### 方案2:动态权重

1.如何标识服务器的处理能力?

2.如何设计动态权重?

> 每成功处理一次请求,+1分
>
> 每失败处理一次请求,-10分
>
> 假设分数0-100    每一台的初始分都为60,刚开始,请求是均衡处理的
>
> 随着时间的推移, 处理能力强的服务器分数越来越高,
>
> 处理能力弱的,不稳定的 ,分数越来越低 
>
> 分数慢慢的变成了100,60,40
>
> 分数的不同,决定了 请求被分配到这台服务器的几率
>
> 这样就实现了, 权重的动态调节

## 异构服务器负载均衡的 过载保护的意义

> 流量压力 到达极限的时候  ,系统雪崩, 就像汽车,散架了一样
>
> 下图为不进行过载保护的情况

![image-20200913151322535](D:\code\PHPWiki\架构设计\必须搞定负载均衡.assets\image-20200913151322535.png)

>  实施了过载保护以后,系统的最大压力,会保持在一个相对稳定的值, 满载运行,但是不会挂掉

![image-20200913151510040](D:\code\PHPWiki\架构设计\必须搞定负载均衡.assets\image-20200913151510040.png)

## 如何实施过载保护?

动态权重法

(1)连接代表服务,分值代表服务(连接)处理能力
(2)处理成功加小分，处理失败扣大分
(3)临界边界 喘小口气

> 比如在发现请求超时,请求失败的的时候, 我们认为他快要处理不过来了
>
> 接下来的10秒钟,不再给这个服务器分配请求
>
> 连续三次都超时,或者处理失败   1分钟内,不再给这个服务器分配请求

(4)死亡状态 喘大口气



如果整体的负载超过了微服务集群的整体承受能力,为了防止雪崩的出现,通过抛弃部分请求来实现服务集群的自我保护

注意:

单个节点的保护方案是  将请求分配到其他节点

整体的保护是,抛弃部分请求









