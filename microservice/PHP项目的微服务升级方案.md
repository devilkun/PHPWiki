## 传统模式存在的问题

### 基于数据库表和MVC实现的服务

![image-20200508192309483](C:\Users\aaa\AppData\Roaming\Typora\typora-user-images\image-20200508192309483.png)

1.存储层 未做隔离 数据不可迁移调整 耦合性极高
2.客户端必须include/require一个文件
3.代码修改必须通知所有业务方升级 
4.可能存在不同版本的兼容问题 
5.无法跨语言，不支持C++、Java等其他语言程序
6.代码过于集中 新人对代码不敢下手

![image-20200508192106778](C:\Users\aaa\AppData\Roaming\Typora\typora-user-images\image-20200508192106778.png)


### HTTP + JSON的WebAPI
1. 解决了耦合问题，可以提供良好的服务隔离 
2. 优点：目前最通用,最简单的服务治理方案 
3. 缺点：a) Http不支持并发，b) 长连接支持差，c) 没有服务治理方案

## 微服务是什么
微服务解耦的本质是把代码内部的复杂性通过一些工具转化外部复杂性。
把代码内部的复杂性分散到各个服务中以降低整体复杂性和架构风险

## 服务的拆分规则
> 关注点分离原则

1.分析业务需求并切分微服务边界。

![image-20200508163047109](C:\Users\aaa\AppData\Roaming\Typora\typora-user-images\image-20200508163047109.png)
#### 第一步：梳理业务流程
#### 第二步：抽取公共服务
与业务无关的功能，独立成单独的服务
如：邮件发送  短信发送  文件上传  音视频转码  长连接转短链接
#### 第三步：定义业务服务
刚开始实施微服务时，不要将业务服务的边界切得太细，可以考虑先“大切几块”，但需要确保每个服务之间尽量不要有依赖关系。换句话说，每个服务都是独立的，虽然此时服务的块头可能比较大。先确保这些大块头服务可以运行在微服务基础设施上，再不断将它们进行细化，拆解为更小的服务。



#### 第四步：设计数据模型
> 数据库表结构设计
> 数据库表关系设计
> 索引设计

####  第五步：定义服务接口
> 职责单一原则
> 版本迭代原则

## 微服务管理

 (1）注册中心：用于注册微服务相关配置信息的中心

（2）API网关：用于提供给前端调用的统一入口  也叫调用中心

（3）部署中心：用于编译并打包微服务源码并将其部署到Docker引擎中，可选用Jenkins实现。

（4）日志中心：用于收集并管理微服务应用程序中产生的日志 可使用ELK系统

（5）监控中心：用于监控微服务的实时运行状况

（6）追踪中心：用于最终微服务的调用轨迹

（7）消息中心：用于解耦微服务之间的调用关系

（8）配置中心：用于管理微服务应用程序所需的配置参数



 

## 方案选择



Yar 



### Tars
> 腾讯开源的框架 
> github上已有8.3k个star

[tars github地址](https://github.com/TarsCloud/Tars/blob/master/README.zh.md)

[官方文档教程](https://tarscloud.github.io/TarsDocs/SUMMARY.html)

> 有针对

#### swoft

> 支持微服务 
>
> Swoft 完美与 Istio/Envoy 等 Service mesh 框架契合，
>
> 同时还为中小型提供一套快速构建微服务治理组件，
>
> 包括服务注册与发现、服务熔断、服务限流，以及配置中心



### [phalconplus](https://github.com/bullsoft/phalconplus)

phalcon 和 yar的结合体



## 微服务化后的差异
#### API接口地址的差异
以前  api.kekestar.cn/user/getInfo?uid=89757
现在   api.kekestar.cn/userServer/user/getInfo/v1?uid=89757

#### Nginx处理请求的差异
nginx接收到请求后
以前 
转发给PHP-FPM的127.0.0.0:9000端口
现在
根据url中的服务名称进行转发 到不同的服务端口 
每个服务的端口是不重复的
如果微服务单机部署  使用ip:端口     方式
如果微服务集群部署 使用域名:端口 方式  （单服务的高可用性）



## 请求调用过程图

![img](https://upload-images.jianshu.io/upload_images/7088501-9aee121e17aeaee7?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

> [API网关]用户访问应用系统时，请求首先将进入API服务网关，因为它是所有请求调用的中心，我们也将其称为“调用中心”。

> [服务发现与调用]随后调用中心将连接注册中心，并通过服务名称从注册中心中获取服务所在的IP地址与端口号（即服务地址），该过程称为“服务发现”，
> 进而调用中心可根据服务地址以反向代理的方式来调用具体的服务容器，该过程称为“服务调用”。

> [消息中心]在服务容器中可能会触发一些事件，这些事件将以消息的方式写入消息中心，以便其他服务可监听消息中心并从中获取相应的消息。
该方案可解决服务之间的耦合问题，同时能将同步调用转为异步调用，提高整个应用系统的吞吐率。

>[日志中心] 在服务运行时会产生大量的日志，我们可将这些日志统一写入日志中心ELK，并能在日志中心所提供的控制台上查询具体的日志信息。
此外，日志中心也能帮助我们快速地定位并分析系统出现的异常状况。

> [服务监控]为了观察服务容器是否运行正常，我们可借助监控中心所输出的图形化数据来判断。监控中心将不断地收集服务容器中的运行状态，包括CPU、内存、硬盘、网络，以及应用程序的JVM内存使用情况。

> [链路追踪中心]由于微服务很难切得干净，服务之间难免会出现少量的调用关系，我们可将每次调用所产生的相关信息写入链路追踪中心，并通过追踪中心提供的图形化界面来查看服务之间的调用轨迹以及所产生的调用延时，从而可分析出服务调用所产生的性能瓶颈



 

## 微服务架构全貌图

![img](https://upload-images.jianshu.io/upload_images/7088501-73d9c0a104ba74ea?imageMogr2/auto-orient/strip|imageView2/2/w/794/format/webp)