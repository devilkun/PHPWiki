## 23种,重要的一共12个

## 抽象类和接口的使用

- 当类中有共同的行为或属性时,可以考虑使用 abstract calss
- 当类别中有共同的操作界面,但是在实现上有所差别,可以考虑使用 interface

# 创建型设计模式

## 定义

对 类的实例化过程 进行了封装    /  对 对象的创建过程 进行了封装 / 把类 实例化为 对象  的过程 进行了封装

创建型模式在创建谁(What)，由谁创建(Who)这2个细节进行封装。隐藏了类的实例的创建细节.

当你需要使用另一个类的时候, 直接New ClassName();  是最低级的写法.

## 

## 单例模式（Singleton）[4颗星]

#### 计划生育-只生一个好



## 简单工厂模式（Simple Factory）[4颗星]

#### 终究还是我一个人抗下了所有

## 工厂方法模式（Factory Method）[5颗星]

#### 需要什么,你自己选

## 抽象工厂模式（Abstract Factory）[5颗星]

> 简单工厂 到 工厂方法 到抽象工厂  是一个逐渐演变的过程

## 原型模式（Prototype）[3颗星]

## 建造者模式（Builder）[2颗星]

## 



---





# 结构型设计模式

## 定义

将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。

## 

### 类 结构型模式

> 类与类 之间的组合
>
> 继承关系和实现关系

### 对象 结构型模式

> 类与对象 之间的组合
>
> 使用组合的弱关系,来代替继承的强关系,减少时间的依赖.

**根据“合成复用原则”，要尽量使用关联关系来取代继承关系，因此大部分结构型设计模式都属于对象行为型设计模式。**

## 

## 外观模式(Facade)[5颗星]

## 组合模式(Composite)[4颗星]

## 代理模式(Proxy)[4颗星]

## 适配器模式(Adapter)[4颗星]

## 桥接模式(Bridge)[3颗星]

### 

## 装饰模式(Decorator)[3颗星]

### 

## 享元模式(Flyweight)[1颗星]

## 



---



# 行为型设计模式

## 定义

对在不同的对象之间划分责任和算法的抽象化。

不仅关注类和对象的结构，而且重点关注它们之间的相互作用。

通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。

在程序运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。

行为型模式分为

### 类行为型模式

使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。

### 对象行为型模式

使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。

**根据“合成复用原则”，要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。**

## 

## 观察者模式(Observer)[5颗星]

## 迭代器模式(Iterator)[5颗星]

## 策略模式(Strategy)[4颗星]

## 命令模式(Command)[4颗星]

## 模板方法模式(Template Method)[3颗星]

## 职责链模式(Chain of Responsibility)[3颗星]

## 状态模式(State)[3颗星]

## 中介者模式(Mediator)[2颗星]

## 备忘录模式(Memento)[2颗星]

## 解释器模式(Interpreter)[1颗星]

## 访问者模式(Visitor)[1颗星]